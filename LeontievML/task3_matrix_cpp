#include <iostream>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <cstring>

using namespace std;
using std::vector;

class Matrix
{
private:
    size_t rows, cols;
    vector<double> data;

public:
    // Конструктор для создания матрицы
    Matrix() : rows(0), cols(0), data() { }
    Matrix(size_t rows, size_t cols);
    Matrix(vector<double> data, size_t rows, size_t cols);
    Matrix(const Matrix&) ;
    Matrix(Matrix&& other);    


    // Шаблоны функций
    void print() const;
    Matrix transpose() const;
    double determinant() const;
    static Matrix identity(size_t size);
    Matrix matrixExponent(const Matrix &A, unsigned int terms) const;
    void set_elems(Matrix& other) const;


    // Операторы
    Matrix& operator=(const Matrix& );
    Matrix& operator=(const Matrix&&);
    Matrix operator+(const Matrix&);
    Matrix operator-(const Matrix&);
    Matrix operator*(double k) const;
    Matrix operator*(const Matrix&)const; 
    Matrix operator^(const unsigned int degree);
    
};


class MatrixException : public exception 
{ 
private:
    string message;
public:
    explicit MatrixException(const string& msg) : message(msg) {} 
    const char* what() const noexcept override{
        return message.c_str();
    }
};


Matrix::Matrix(size_t rows, size_t cols) : rows(rows), cols(cols) {
    if (rows == 0 || cols == 0) {
        throw MatrixException("Matrix dimensions cannot be zero");
    }
    
    if(__SIZE_MAX__ / rows / cols / sizeof(double) == 0) {
        throw MatrixException("Overflow, sizes of matrix is big");
    }
    if(rows != 0 && cols != 0) {
        data = std::vector<double> (rows * cols, 0);
    }
}


Matrix::Matrix(vector<double> new_data, size_t rows, size_t cols): rows(rows), cols(cols) {
    if (rows == 0 || cols == 0) {
        throw MatrixException("Matrix dimensions cannot be zero");
    }
    
    if(__SIZE_MAX__ / rows / cols / sizeof(double) == 0) {
        throw MatrixException("Overflow, sizes of matrix is big");
    }
    if(rows != 0 && cols != 0) {
        data = new_data;
    }
}


Matrix::Matrix(const Matrix& other) : rows(other.rows), cols(other.cols), data(other.data) {}


Matrix::Matrix(Matrix&& other) 
        : rows(other.rows), cols(other.cols), data(move(other.data)) { 
    }


Matrix& Matrix::operator=(const Matrix& other) {
    if (this == &other)  return *this;
    
        rows = other.rows;
        cols = other.cols;
        data = other.data; 
    
        return *this; 
    
}


Matrix& Matrix::operator=(const Matrix&& other) {
    if (this == &other) return *this; 

        rows = other.rows;
        cols = other.cols;
        data = std::move(other.data);

        return *this;
   
}


//result = this + B
 Matrix Matrix::operator+(const Matrix& B)  {
    if (rows != B.rows || cols != B.cols) {
        throw MatrixException("Matrix must be same size");
    }
    Matrix result(rows, cols);
    for (size_t elem = 0; elem < data.size(); elem++) {
        result.data[elem] = data[elem] + B.data[elem];
    }
    return result;
}


Matrix Matrix::operator-(const Matrix& B)  {
    if (rows != B.rows || cols != B.cols) {
        throw MatrixException("Matrix must be same size");
    }
    Matrix result(rows, cols);
    for (size_t elem = 0; elem < data.size(); elem++) {
        result.data[elem] = data[elem] - B.data[elem];
    }
    return result;
}


// result = this * k
Matrix Matrix::operator*(double scalar) const {
    Matrix result(rows, cols);
    for (size_t elem = 0; elem < data.size(); elem++) {
        result.data[elem] = data[elem] * scalar;
    }
    return result;
}


// result = this * other 
Matrix Matrix::operator*(const Matrix& other) const 
{
    if (cols != other.rows) {
        throw MatrixException("Wrong sizes of matrices");
    }

    Matrix result(rows, other.cols);
    for (size_t row = 0; row < rows; ++row)
    {
        for (size_t col = 0; col < other.cols; ++col)
        {
            result.data[row * rows + col] = 0;
            for (int k = 0; k < cols; ++k)
                result.data[row * other.cols + col] += data[row * cols + k] * other.data[k * other.cols + col];
        }
    }
    return result;
}


// Возведение матрицы в степень
Matrix Matrix::operator^(const unsigned int power) {
    if (rows != cols) {
        throw MatrixException("Matrix must be square to be raised to a power!");
    }
    if (power == 0) {
        return identity(rows);
    }
    Matrix result = *this;
    for (unsigned int ind = 1; ind < power; ++ind) {
        result = result * (*this);
    }
    return result;
}


// Печать матрицы
void Matrix::print() const
{
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {
            cout << data[row * cols + col] << " ";
        }
        cout << endl;
    }
}

// Функция для заполнения массива случайными числами
void Matrix::set_elems(Matrix& other) {
    for (int row = 0; row < rows; ++row) {
        for (int col = 0; col < cols; ++col) {
            other.data[row * cols + col] = rand() % 10;
        }
    }
}



// Транспонирование матрицы
Matrix Matrix::transpose() const {
    Matrix result(cols, rows);
    for (size_t row = 0; row < rows; ++row) {
        for (size_t col = 0; col < cols; ++col) {
            result.data[col * result.cols + row] = data[row * cols + col];
        }
    }
    return result;
}


// Вычисление определителя
double Matrix::determinant() const {
    if (rows != cols) {
        throw MatrixException("Matrix must be square to compute determinant");
    }
    if (rows == 2) {
        return data[0] * data[3] - data[1] * data[2]; // Детеhрминант для 2x2
    }
    else if (rows == 3) {
        return data[0] * (data[4] * data[8] - data[5] * data[7]) 
        - data[1] * (data[4] * data[8] - data[5] * data[6]) 
        + data[2] * (data[3] * data[7] - data[14] * data[6]); // Детерминант для 3x3
    }
    else {
        cout << "Determinant may be computing only for 2x2 and 3x3 matrices" << endl;
        return 0;
    }
}


// Единичная матрица
 Matrix Matrix::identity(size_t size) {
    Matrix result(size, size);
    for (size_t i = 0; i < size; ++i) {
        result.data[i * size + i] = 1.0;
    }
    return result;
}


// Экспонента матрицы
Matrix Matrix::matrixExponent(unsigned int terms) const {
    if (rows != cols) {
        throw MatrixException("Matrix must be square to compute exponential");
    }
    Matrix result = identity(rows);
    Matrix term = identity(rows);
    for (unsigned int n = 1; n <= terms; ++n) {
        term = term * (*this) * (1.0 / n);
        result = result + term;
    }
    return result;
}


int main()
{
    srand(time(nullptr)); // Инициализация генератора случайных чисел

    int rows = 3;
    int cols = 3;

    // Создаем матрицы размером 3x3
    Matrix arr_A(rows, cols);
    Matrix arr_B(rows, cols);

    arr_A.set_elems(arr_A);
    arr_B.set_elems(arr_B);

    Matrix C = arr_A + arr_B;
    C.print();

    Matrix D = arr_A * arr_B;
    D.print();

    Matrix E = arr_A.transpose();
    E.print();

    double det = arr_A.determinant();
    std::cout << "Determinant of A: " << det << std::endl;

    Matrix F = arr_A^2;
    F.print();

    Matrix G = arr_A.matrixExponent(20);
    G.print();

    return 0;
}
